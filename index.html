<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pac-DNA Mastery Lab (Themes + Power Pellets)</title>
<style>
  :root{
    --bg0:#070a16; --bg1:#0b1230;
    --card: rgba(255,255,255,0.07);
    --stroke: rgba(255,255,255,0.12);
    --text:#eef2ff; --muted:#aab3d1;
    --accent:#7cc4ff; --accent2:#b79cff;
    --good:#4ee59a; --warn:#ffd166; --bad:#ff5c7a;
    --shadow: 0 14px 42px rgba(0,0,0,0.38);
    --r:18px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:var(--text);
    background:
      radial-gradient(900px 550px at 18% 0%, #1a2a74 0%, rgba(26,42,116,0) 60%),
      radial-gradient(900px 550px at 85% 10%, #3a1f6b 0%, rgba(58,31,107,0) 60%),
      linear-gradient(180deg, var(--bg1), var(--bg0));
    min-height:100vh;
  }
  header{
    max-width:1180px; margin:0 auto; padding:22px 16px 10px;
    display:flex; justify-content:space-between; align-items:flex-end; gap:12px; flex-wrap:wrap;
  }
  h1{margin:0; font-size:28px; line-height:1.1}
  .sub{margin:8px 0 0; color:var(--muted); max-width:110ch}
  .kbd{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    font-size:12px; padding:2px 6px;
    border:1px solid var(--stroke); border-radius:8px;
    background: rgba(255,255,255,0.05);
  }
  main{
    max-width:1180px; margin:0 auto; padding:10px 16px 36px;
    display:grid; gap:14px;
    grid-template-columns: 1fr;
  }
  @media (min-width: 980px){
    main{grid-template-columns: 1.2fr 0.8fr;}
  }
  .card{
    background:var(--card);
    border:1px solid var(--stroke);
    border-radius: var(--r);
    box-shadow: var(--shadow);
    padding:14px;
    backdrop-filter: blur(10px);
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .pill{
    display:inline-flex; gap:8px; align-items:center;
    padding:7px 10px; border-radius:999px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.06);
    font-size:12px; color:var(--muted);
  }
  .pill strong{color:var(--text)}
  button, select{
    background: rgba(255,255,255,0.06);
    border:1px solid var(--stroke);
    color:var(--text);
    border-radius:12px;
    padding:10px 10px;
    font-size:14px;
    outline:none;
  }
  button{cursor:pointer; font-weight:900}
  button:hover{border-color: rgba(255,255,255,0.22)}
  .primary{background: rgba(124,196,255,0.18); border-color: rgba(124,196,255,0.35)}
  .danger{background: rgba(255,92,122,0.12); border-color: rgba(255,92,122,0.26)}
  .ghostBtn{background: rgba(255,255,255,0.05)}
  label{font-size:12px; color:var(--muted); font-weight:900}
  canvas{
    width:100%;
    border-radius:16px;
    border:1px solid var(--stroke);
    background: rgba(0,0,0,0.22);
    display:block;
  }
  .panel{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    border-radius: 16px;
    padding:12px;
  }
  .panel h3{margin:0 0 8px; font-size:14px}
  .small{font-size:12px; color:var(--muted)}
  .qText{font-size:18px; margin:10px 0 10px; line-height:1.25}
  .answers{display:grid; gap:10px}
  .answerBtn{
    text-align:left;
    padding:12px 12px;
    border-radius: 14px;
    border: 1px solid var(--stroke);
    background: rgba(255,255,255,0.05);
    display:flex; gap:10px; align-items:flex-start;
    line-height:1.2;
  }
  .answerBtn .letter{
    width:28px;height:28px;border-radius:10px;
    display:grid;place-items:center;
    font-weight:1000;
    background: rgba(255,255,255,0.07);
    border:1px solid rgba(255,255,255,0.10);
    color: var(--text);
    flex: 0 0 auto;
  }
  .answerBtn.correct{border-color: rgba(78,229,154,0.55); background: rgba(78,229,154,0.12)}
  .answerBtn.wrong{border-color: rgba(255,92,122,0.55); background: rgba(255,92,122,0.11)}
  .answerBtn.locked{cursor:default; opacity:0.98}
  .feedback{
    margin-top:12px;
    padding:12px;
    border-radius: 14px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    display:none;
  }
  .feedback.good{border-color: rgba(78,229,154,0.45); background: rgba(78,229,154,0.10)}
  .feedback.bad{border-color: rgba(255,92,122,0.45); background: rgba(255,92,122,0.09)}
  .feedback .title{font-weight:1000; display:flex;align-items:center;gap:8px; margin-bottom:6px}
  .feedback p{margin:0;color:var(--muted)}
  .explain{margin-top:8px; color:var(--text); font-size:14px; line-height:1.35}
  .targetCard{
    border:1px solid var(--stroke);
    border-radius:16px;
    background: rgba(255,255,255,0.04);
    padding:10px;
    margin-top:10px;
  }
  .targetTop{display:flex; justify-content:space-between; gap:10px; align-items:flex-start}
  .targetTitle{font-weight:1000}
  .targetStd{font-size:12px; color:var(--muted)}
  .status{
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.05);
    color: var(--muted);
    white-space:nowrap;
  }
  .status.mastered{
    border-color: rgba(78,229,154,0.45);
    background: rgba(78,229,154,0.10);
    color: var(--text);
  }
  .bar{
    height:10px; border-radius:999px;
    background: rgba(255,255,255,0.10);
    overflow:hidden; margin-top:8px;
  }
  .bar > div{
    height:100%;
    width:0%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
  }
</style>
</head>
<body>

<header>
  <div>
    <h1>Pac-DNA Mastery Lab</h1>
    <p class="sub">
      Correct answers give <b>Moves</b>. Use moves to collect dots ‚ö™ and power pellets ‚≠ê while dodging ghosts üëª.
      Clear all dots to <b>Level Up</b> ‚Äî the maze regenerates with a new <b>theme</b>.
      Warp tunnels: left ‚Üî right in the middle row.
    </p>
  </div>
  <div class="small">
    Controls: <span class="kbd">Arrow Keys</span> move ‚Ä¢ <span class="kbd">1‚Äì4</span> answer ‚Ä¢ <span class="kbd">N</span> next ‚Ä¢ <span class="kbd">R</span> reset
  </div>
</header>

<main>
  <section class="card">
    <div class="panel" style="margin-bottom:12px">
      <div class="row" style="justify-content:space-between;">
        <div class="row">
          <span class="pill"><strong>Theme:</strong> <span id="themeName">‚Äî</span></span>
          <span class="pill"><strong>Character:</strong> <span id="charName">Mr. Pac-Cell</span></span>
          <span class="pill"><strong>Level:</strong> <span id="levelNum">1</span></span>
          <span class="pill"><strong>Moves:</strong> <span id="movesNum">0</span></span>
          <span class="pill"><strong>Lives:</strong> <span id="livesNum">3</span></span>
          <span class="pill"><strong>Dots:</strong> <span id="dotsLeft">0</span></span>
          <span class="pill"><strong>Ghosts:</strong> <span id="ghostCount">1</span></span>
          <span class="pill"><strong>Game Score:</strong> <span id="gameScore">0</span></span>
          <span class="pill"><strong>Power:</strong> <span id="powerTime">0.0</span>s</span>
        </div>
        <div class="row">
          <div>
            <label for="charSelect">Mode</label><br/>
            <select id="charSelect">
              <option value="mr">Mr. Pac-Cell</option>
              <option value="ms">Ms. Pac-Cell</option>
            </select>
          </div>
          <button class="ghostBtn" id="soundBtn">üîä Sound</button>
          <button class="danger" id="resetBtn">Reset</button>
        </div>
      </div>
      <div class="small" style="margin-top:8px">
        ‚≠ê Power pellet: ghosts turn blue (frightened). Touch them to ‚Äúeat‚Äù them for points.
      </div>
    </div>

    <canvas id="game" width="860" height="520"></canvas>

    <div class="panel" style="margin-top:12px">
      <div class="row" style="justify-content:space-between;">
        <span class="pill" id="skillPill"><strong>Skill:</strong> ‚Äî</span>
        <span class="pill"><strong>Streak:</strong> <span id="streakNum">0</span></span>
      </div>

      <div class="row" style="justify-content:space-between; margin-top:10px;">
        <div style="flex:1; min-width:220px;">
          <label for="targetSelect">Practice</label><br/>
          <select id="targetSelect"></select>
        </div>
        <div style="min-width:210px;">
          <label for="modeSelect">Question Mode</label><br/>
          <select id="modeSelect">
            <option value="adaptive">Adaptive Mastery</option>
            <option value="random">Random Practice</option>
            <option value="missed">Review Missed Only</option>
          </select>
        </div>
      </div>

      <div class="qText" id="questionText">Loading‚Ä¶</div>
      <div class="answers" id="answers"></div>

      <div class="feedback" id="feedback">
        <div class="title"><span id="fbIcon">‚Ä¢</span><div id="fbHeadline">‚Äî</div></div>
        <p id="fbShort">‚Äî</p>
        <div class="explain" id="fbExplain"></div>
      </div>

      <div class="row" style="margin-top:10px; justify-content:space-between;">
        <button class="ghostBtn" id="hintBtn">Hint</button>
        <button class="primary" id="nextBtn">Next Question</button>
      </div>
    </div>
  </section>

  <aside class="card">
    <div class="panel">
      <h3>NGSS-Aligned Learning Targets</h3>
      <div class="small">Targets turn mastered as related skills reach streak + accuracy thresholds.</div>
      <div id="targetsPanel"></div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>Quiz Progress</h3>
      <div class="row">
        <span class="pill"><strong>Score:</strong> <span id="quizScore">0</span>/<span id="quizAnswered">0</span></span>
        <span class="pill"><strong>Accuracy:</strong> <span id="quizAcc">‚Äî</span></span>
      </div>
      <div class="small" style="margin-top:8px">Adaptive mode repeats skills you miss more often.</div>
    </div>
  </aside>
</main>

<script>
/* =========================
   Helpers
   ========================= */
const el = (id)=>document.getElementById(id);
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* =========================
   Sound (no files)
   ========================= */
let soundOn = true;
let audioCtx = null;
function beep(freq=660, dur=0.07, gain=0.06, type="sine"){
  if(!soundOn) return;
  try{
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>o.stop(), dur*1000);
  }catch(e){}
}
el("soundBtn").addEventListener("click", ()=>{
  soundOn = !soundOn;
  el("soundBtn").textContent = soundOn ? "üîä Sound" : "üîá Sound";
});

/* =========================
   Themes
   ========================= */
const THEMES = [
  { name:"Replication Lab", bg:"rgba(124,196,255,0.06)", wallFill:"rgba(124,196,255,0.22)", wallStroke:"rgba(183,156,255,0.35)", dot:"#eef2ff", pellet:"#ffd166" },
  { name:"Central Dogma City", bg:"rgba(255,209,102,0.05)", wallFill:"rgba(255,209,102,0.16)", wallStroke:"rgba(124,196,255,0.30)", dot:"#eef2ff", pellet:"#7cc4ff" },
  { name:"Nucleus Night", bg:"rgba(183,156,255,0.06)", wallFill:"rgba(183,156,255,0.18)", wallStroke:"rgba(124,196,255,0.28)", dot:"#f5f3ff", pellet:"#ffd166" },
  { name:"Chromosome Carnival", bg:"rgba(255,92,122,0.05)", wallFill:"rgba(255,92,122,0.14)", wallStroke:"rgba(255,209,102,0.22)", dot:"#fff7ed", pellet:"#b79cff" },
];
function themeForLevel(lvl){ return THEMES[(lvl-1) % THEMES.length]; }
let theme = themeForLevel(1);

/* =========================
   Learning Targets
   ========================= */
const TARGETS = [
  { key:"T1_CENTRAL_DOGMA", title:"1) Explain the flow of genetic information (Central Dogma).", standards:"HS-LS1-1",
    studentText:"I can explain DNA ‚Üí RNA ‚Üí Protein and connect gene sequence to protein outcomes.",
    skills:["Central Dogma","Transcription","Translation","Central Dogma reasoning"] },
  { key:"T2_DNA_STRUCTURE", title:"2) Label and describe the structure of DNA.", standards:"HS-LS1-1",
    studentText:"I can identify nucleotides, the sugar-phosphate backbone, base pairing, and bonds.",
    skills:["Nucleotide","Phosphate","Deoxyribose Sugar","Nitrogen Base","Complementary Bases","Hydrogen Bonds","Covalent Bonds"] },
  { key:"T3_REPLICATION", title:"3) Describe how DNA replication preserves genetic information.", standards:"HS-LS3-1, HS-LS1-1",
    studentText:"I can explain replication and the roles of helicase, DNA polymerase, and ligase.",
    skills:["Replication overview","Helicase","DNA polymerase","Ligase","Replication reasoning"] },
  { key:"T4_DNA_VS_RNA", title:"4) Compare and contrast DNA and RNA.", standards:"HS-LS1-1, HS-LS3-1",
    studentText:"I can compare sugar, bases, strands, and roles in protein synthesis.",
    skills:["DNA vs RNA","Ribose Sugar","Deoxyribose Sugar","RNA"] },
  { key:"T5_VOCAB", title:"5) Use genetic vocabulary precisely in explanations.", standards:"HS-LS3-1",
    studentText:"I can use key terms accurately in context and apply them to diagrams and scenarios.",
    skills:["Nucleic Acid","Nucleotide","Phosphate","Deoxyribose Sugar","Ribose Sugar","RNA","Nitrogen Base","Complementary Bases","Hydrogen Bonds","Covalent Bonds"] }
];
const TARGET_SELECT = [
  {key:"ALL", label:"All Targets"},
  {key:"T1_CENTRAL_DOGMA", label:"Target 1: Central Dogma"},
  {key:"T2_DNA_STRUCTURE", label:"Target 2: DNA Structure"},
  {key:"T3_REPLICATION", label:"Target 3: DNA Replication"},
  {key:"T4_DNA_VS_RNA", label:"Target 4: DNA vs RNA"},
  {key:"T5_VOCAB", label:"Target 5: Vocabulary Precision"},
];
function buildTargetSelect(){
  const s = el("targetSelect");
  s.innerHTML = "";
  TARGET_SELECT.forEach(o=>{
    const opt = document.createElement("option");
    opt.value = o.key;
    opt.textContent = o.label;
    s.appendChild(opt);
  });
  s.value = "ALL";
}

/* =========================
   Question Bank
   ========================= */
const QUESTION_BANK = [
  {id:"CD1", targetKey:"T1_CENTRAL_DOGMA", skill:"Central Dogma",
    q:"Which sequence correctly shows the usual flow of genetic information?",
    choices:["Protein ‚Üí RNA ‚Üí DNA","DNA ‚Üí RNA ‚Üí Protein","RNA ‚Üí DNA ‚Üí Protein","DNA ‚Üí Protein ‚Üí RNA"],
    answer:1, explain:"Central Dogma: DNA is transcribed into RNA, and RNA is translated into protein."},
  {id:"CD2", targetKey:"T1_CENTRAL_DOGMA", skill:"Transcription",
    q:"Transcription makes‚Ä¶",
    choices:["DNA from protein","mRNA from DNA","protein from mRNA","DNA from RNA"],
    answer:1, explain:"Transcription produces an RNA copy (mRNA) from a DNA template."},
  {id:"CD3", targetKey:"T1_CENTRAL_DOGMA", skill:"Translation",
    q:"Translation makes‚Ä¶",
    choices:["protein from mRNA","mRNA from DNA","DNA from protein","RNA from DNA in the nucleus only"],
    answer:0, explain:"Translation uses mRNA at ribosomes to build a protein."},
  {id:"CD4", targetKey:"T1_CENTRAL_DOGMA", skill:"Central Dogma reasoning",
    q:"A mutation changes DNA in a gene. What is the most likely chain of effects?",
    choices:[
      "DNA changes ‚Üí mRNA may change ‚Üí protein may change ‚Üí trait may change",
      "DNA changes ‚Üí protein changes directly (no RNA involved)",
      "DNA changes ‚Üí chromosomes disappear",
      "DNA changes ‚Üí the cell always dies"
    ],
    answer:0, explain:"DNA changes can alter mRNA codons, amino acids, protein function, and traits."},

  {id:"S5", targetKey:"T2_DNA_STRUCTURE", skill:"Nucleotide",
    q:"A DNA nucleotide is made of‚Ä¶",
    choices:["phosphate + sugar + nitrogen base","protein + lipid + sugar","amino acids only","ribose + uracil only"],
    answer:0, explain:"A nucleotide has a phosphate group, a sugar, and a nitrogen base."},
  {id:"V2", targetKey:"T2_DNA_STRUCTURE", skill:"Phosphate",
    q:"In a DNA nucleotide, the phosphate group is part of the‚Ä¶",
    choices:["nitrogen base","sugar-phosphate backbone","hydrogen bonds","amino acid chain"],
    answer:1, explain:"Phosphate (with sugar) forms the backbone of DNA."},
  {id:"V3", targetKey:"T2_DNA_STRUCTURE", skill:"Deoxyribose Sugar",
    q:"Which sugar is found in DNA?",
    choices:["Ribose","Deoxyribose","Sucrose","Lactose"],
    answer:1, explain:"DNA contains deoxyribose; RNA contains ribose."},
  {id:"V4", targetKey:"T2_DNA_STRUCTURE", skill:"Nitrogen Base",
    q:"A nitrogen base in DNA refers to‚Ä¶",
    choices:["A, T, C, or G","the phosphate group","the sugar in the backbone","the enzyme helicase"],
    answer:0, explain:"Nitrogen bases are A, T, C, and G in DNA."},
  {id:"S1", targetKey:"T2_DNA_STRUCTURE", skill:"Complementary Bases",
    q:"In DNA, Adenine (A) pairs with‚Ä¶",
    choices:["Cytosine (C)","Guanine (G)","Thymine (T)","Uracil (U)"],
    answer:2, explain:"Complementary base pairing in DNA: A‚ÄìT and C‚ÄìG (U is in RNA)."},
  {id:"S3", targetKey:"T2_DNA_STRUCTURE", skill:"Hydrogen Bonds",
    q:"What holds complementary bases together across the two DNA strands?",
    choices:["Covalent bonds","Hydrogen bonds","Peptide bonds","Ionic bonds"],
    answer:1, explain:"Bases pair across strands with hydrogen bonds; the backbone uses covalent bonds."},
  {id:"S4", targetKey:"T2_DNA_STRUCTURE", skill:"Covalent Bonds",
    q:"What type of bond makes the sugar-phosphate backbone strong and stable?",
    choices:["Hydrogen bonds","Covalent bonds","Peptide bonds","None"],
    answer:1, explain:"Covalent bonds connect sugar and phosphate in the backbone."},

  {id:"R1", targetKey:"T3_REPLICATION", skill:"Replication overview",
    q:"DNA replication is best described as‚Ä¶",
    choices:["making RNA from DNA","copying DNA before cell division","making protein from RNA","changing DNA into RNA permanently"],
    answer:1, explain:"Replication copies DNA so each daughter cell receives a complete set of genetic information."},
  {id:"R2", targetKey:"T3_REPLICATION", skill:"Helicase",
    q:"Which enzyme ‚Äòunzips‚Äô DNA by breaking hydrogen bonds?",
    choices:["Ligase","DNA polymerase","Helicase","Ribosome"],
    answer:2, explain:"Helicase separates strands by breaking hydrogen bonds between base pairs."},
  {id:"R3", targetKey:"T3_REPLICATION", skill:"DNA polymerase",
    q:"Which enzyme adds complementary nucleotides to build a new DNA strand?",
    choices:["Ligase","Helicase","DNA polymerase","tRNA"],
    answer:2, explain:"DNA polymerase synthesizes the new strand by adding complementary nucleotides."},
  {id:"R4", targetKey:"T3_REPLICATION", skill:"Ligase",
    q:"Which enzyme ‚Äòglues‚Äô DNA fragments together?",
    choices:["Ligase","Helicase","DNA polymerase","RNA polymerase"],
    answer:0, explain:"Ligase seals gaps by forming covalent bonds between fragments."},
  {id:"R5", targetKey:"T3_REPLICATION", skill:"Replication reasoning",
    q:"Why does DNA unzip by breaking hydrogen bonds instead of the backbone?",
    choices:[
      "Hydrogen bonds are weaker than covalent backbone bonds",
      "Hydrogen bonds are stronger than covalent bonds",
      "The backbone is held together by hydrogen bonds",
      "Bases are connected by peptide bonds"
    ],
    answer:0, explain:"Hydrogen bonds (between bases) are easier to break than covalent bonds (backbone)."},

  {id:"DVR1", targetKey:"T4_DNA_VS_RNA", skill:"DNA vs RNA",
    q:"Which difference between DNA and RNA is correct?",
    choices:[
      "DNA uses uracil; RNA uses thymine",
      "DNA is usually double-stranded; RNA is usually single-stranded",
      "DNA has ribose; RNA has deoxyribose",
      "DNA leaves the nucleus easily; RNA never does"
    ],
    answer:1, explain:"DNA is typically double-stranded; RNA is typically single-stranded. DNA has thymine; RNA has uracil."},
  {id:"DVR2", targetKey:"T4_DNA_VS_RNA", skill:"RNA",
    q:"Which statement best defines RNA?",
    choices:[
      "A nucleic acid involved in carrying messages and building proteins",
      "A protein that unzips DNA",
      "A lipid that stores long-term energy",
      "A carbohydrate used for cell walls"
    ],
    answer:0, explain:"RNA is a nucleic acid used in gene expression (mRNA, tRNA, rRNA)."},
  {id:"DVR3", targetKey:"T4_DNA_VS_RNA", skill:"Ribose Sugar",
    q:"Which sugar is found in RNA?",
    choices:["Deoxyribose","Ribose","Glucose","Fructose"],
    answer:1, explain:"RNA contains ribose sugar (DNA contains deoxyribose)."},

  {id:"V1", targetKey:"T5_VOCAB", skill:"Nucleic Acid",
    q:"DNA and RNA are examples of which type of molecule?",
    choices:["Lipids","Carbohydrates","Nucleic acids","Proteins"],
    answer:2, explain:"DNA and RNA are nucleic acids (store/use genetic information)."},
  {id:"VR2", targetKey:"T5_VOCAB", skill:"Ribose Sugar",
    q:"Which sugar is found in RNA?",
    choices:["Deoxyribose","Ribose","Sucrose","Lactose"],
    answer:1, explain:"RNA contains ribose."}
];

/* =========================
   Adaptive tracking
   ========================= */
const SKILL_TRACK = {};
function tSkill(skill){ SKILL_TRACK[skill] ??= {c:0,w:0,st:0}; return SKILL_TRACK[skill]; }
function isSkillMastered(skill){
  const t = tSkill(skill);
  return (t.st >= 3 && t.c >= 3 && t.w <= 2);
}
function targetProgress(targetKey){
  const target = TARGETS.find(t=>t.key===targetKey);
  if(!target) return {pct:0, mastered:false, masteredCount:0, total:1};
  const total = target.skills.length || 1;
  const masteredCount = target.skills.filter(isSkillMastered).length;
  const pct = Math.round((masteredCount/total)*100);
  const mastered = masteredCount === total;
  return {pct, mastered, masteredCount, total};
}
function renderTargetsPanel(){
  const wrap=el("targetsPanel");
  wrap.innerHTML="";
  TARGETS.forEach(t=>{
    const prog=targetProgress(t.key);
    const card=document.createElement("div");
    card.className="targetCard";
    card.innerHTML=`
      <div class="targetTop">
        <div>
          <div class="targetTitle">${t.title}</div>
          <div class="targetStd">Aligned: <b>${t.standards}</b></div>
          <div class="small" style="margin-top:6px">${t.studentText}</div>
          <div class="small" style="margin-top:6px">Mastered skills: <b>${prog.masteredCount}</b> / <b>${prog.total}</b></div>
        </div>
        <div class="status ${prog.mastered ? "mastered":""}">
          ${prog.mastered ? "‚úÖ Mastered" : "‚è≥ In progress"}
        </div>
      </div>
      <div class="bar"><div style="width:${prog.pct}%"></div></div>
    `;
    wrap.appendChild(card);
  });
}

/* =========================
   Quiz logic
   ========================= */
let mode = "adaptive";
let selectedTargetKey = "ALL";
let current = null;
let locked = false;
let quizAnswered = 0;
let quizScore = 0;
let streak = 0;
let missedIds = new Set();

function quizAccuracy(){ return quizAnswered ? Math.round((quizScore/quizAnswered)*100) : null; }
function updateQuizUI(){
  el("quizScore").textContent = String(quizScore);
  el("quizAnswered").textContent = String(quizAnswered);
  const acc = quizAccuracy();
  el("quizAcc").textContent = (acc===null) ? "‚Äî" : `${acc}%`;
  el("streakNum").textContent = String(streak);
}
function buildPool(){
  const base = QUESTION_BANK.filter(q => selectedTargetKey==="ALL" ? true : q.targetKey===selectedTargetKey);
  if(mode==="random"){ const p=[...base]; shuffle(p); return p; }
  if(mode==="missed"){ const p=base.filter(q=>missedIds.has(q.id)); shuffle(p); return p; }
  return base;
}
function weightForQuestion(q){
  const t = tSkill(q.skill);
  let w = 1.0;
  w += Math.max(0, t.w - t.c) * 0.9;
  w += (3 - Math.min(3, t.st)) * 0.6;
  w *= (0.85 + Math.random()*0.30);
  return Math.max(0.15, w);
}
function pickAdaptive(pool){
  const weights = pool.map(weightForQuestion);
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for(let i=0;i<pool.length;i++){ r -= weights[i]; if(r<=0) return pool[i]; }
  return pool[pool.length-1];
}
let randomIndex=0, randomPoolCache=[];
function nextQuestion(){
  const pool = buildPool();
  if(!pool.length){
    el("questionText").textContent = "No questions match your current setting. Try All Targets.";
    el("answers").innerHTML = "";
    el("feedback").style.display = "none";
    return;
  }
  if(mode==="adaptive") current = pickAdaptive(pool);
  else {
    if(randomPoolCache.length===0 || randomIndex>=randomPoolCache.length){ randomPoolCache=pool; randomIndex=0; }
    current = randomPoolCache[randomIndex++];
  }

  locked=false;
  el("feedback").style.display="none";
  el("skillPill").innerHTML = `<strong>Skill:</strong> ${current.skill}`;
  el("questionText").textContent = current.q;

  const letters=["A","B","C","D"];
  const wrap=el("answers"); wrap.innerHTML="";
  current.choices.forEach((c,i)=>{
    const btn=document.createElement("button");
    btn.type="button";
    btn.className="answerBtn";
    btn.innerHTML=`<div class="letter">${letters[i]}</div><div>${c}</div>`;
    btn.addEventListener("click",()=>chooseAnswer(i));
    wrap.appendChild(btn);
  });
}
function showFeedback(good, headline, short, explain){
  const fb=el("feedback");
  fb.style.display="block";
  fb.classList.remove("good","bad");
  fb.classList.add(good?"good":"bad");
  el("fbIcon").textContent = good ? "‚úÖ" : "‚ùå";
  el("fbHeadline").textContent = headline;
  el("fbShort").textContent = short;
  el("fbExplain").textContent = explain;
}
function chooseAnswer(i){
  if(locked || !current) return;
  locked=true;

  const btns=[...document.querySelectorAll(".answerBtn")];
  btns.forEach(b=>b.classList.add("locked"));

  quizAnswered++;
  const correct=current.answer;
  btns[correct].classList.add("correct");
  if(i!==correct) btns[i].classList.add("wrong");

  const t=tSkill(current.skill);

  if(i===correct){
    quizScore++;
    streak++;
    t.c++; t.st++;
    showFeedback(true,"Correct!","You earned movement power.",current.explain);
    const moveGain = 5 + Math.min(8, level) + (streak>=3 ? 2 : 0);
    moves += moveGain;
    beep(740,0.06,0.06);
  }else{
    streak=0;
    t.w++; t.st=0;
    missedIds.add(current.id);
    showFeedback(false,"Not quite.",`Correct: ${["A","B","C","D"][correct]} ‚Äî ${current.choices[correct]}`,current.explain);
    beep(220,0.10,0.07,"square");
  }

  updateQuizUI();
  renderTargetsPanel();
  updateHUD();
}
function hint(){
  if(!current) return;
  const hints = {
    "Central Dogma":"Storage ‚Üí message ‚Üí product (DNA ‚Üí RNA ‚Üí protein).",
    "Transcription":"DNA becomes an RNA message (mRNA).",
    "Translation":"mRNA is used to build a protein at ribosomes.",
    "Nucleotide":"3 parts: phosphate + sugar + base.",
    "Phosphate":"Backbone component (sugar-phosphate).",
    "Deoxyribose Sugar":"DNA sugar = deoxyribose.",
    "Ribose Sugar":"RNA sugar = ribose.",
    "Nitrogen Base":"A, T, C, G in DNA.",
    "Complementary Bases":"A‚ÄìT and C‚ÄìG in DNA.",
    "Hydrogen Bonds":"Weaker bonds between bases across strands.",
    "Covalent Bonds":"Strong bonds in sugar-phosphate backbone.",
    "Replication overview":"Copy DNA before cell division.",
    "Helicase":"Unzips DNA (breaks hydrogen bonds).",
    "DNA polymerase":"Adds complementary nucleotides.",
    "Ligase":"Seals fragments together.",
    "DNA vs RNA":"Compare sugar + base + strands + role.",
    "RNA":"Nucleic acid used in gene expression."
  };
  showFeedback(true,"Hint","Use this clue, then answer:", hints[current.skill] || "Use structure‚Üífunction and Central Dogma logic.");
  beep(520,0.06,0.05);
}

/* =========================
   Game: tiles + pellets + ghosts + warp
   ========================= */
const game=el("game");
const gctx=game.getContext("2d");

const TILE=24;
const GRID_W=29;
const GRID_H=19;
const OFFSET_X=12;
const OFFSET_Y=12;

const WALL=1, DOT=2, EMPTY=0, PELLET=3;

let grid=[];
let dotsLeft=0;
let lives=3;
let moves=0;
let level=1;
let gameScore=0;

let pac={x:1,y:1, dir:{x:0,y:0}};
let ghosts=[];
let ghostTick=0;

// power pellets
let powerUntil = 0; // performance.now() timestamp
function powerSecondsLeft(){ return Math.max(0, (powerUntil - performance.now())/1000); }
function powered(){ return performance.now() < powerUntil; }

let charMode="mr";
el("charSelect").addEventListener("change", ()=>{
  charMode=el("charSelect").value;
  el("charName").textContent=(charMode==="ms") ? "Ms. Pac-Cell" : "Mr. Pac-Cell";
  drawGame();
});

// Ghost colors
const GHOST_COLORS=["#ff5c7a","#7cc4ff","#ffd166","#b79cff"];

// Ghost count by level (caps at 4)
function ghostCountForLevel(){
  if(level>=6) return 4;
  if(level>=4) return 3;
  if(level>=2) return 2;
  return 1;
}
function ghostSpeedFrames(){
  return clamp(10 - Math.floor((level-1)*0.8), 2, 10);
}

/* ---------- Maze generation (connected) ---------- */
function generateMaze(){
  grid = Array.from({length: GRID_H}, ()=>Array(GRID_W).fill(WALL));
  const inBounds=(x,y)=> x>0 && y>0 && x<GRID_W-1 && y<GRID_H-1;
  const stack=[{x:1,y:1}];
  grid[1][1]=EMPTY;
  const dirs=[{x:2,y:0},{x:-2,y:0},{x:0,y:2},{x:0,y:-2}];

  while(stack.length){
    const cur=stack[stack.length-1];
    const neighbors=[];
    for(const d of dirs){
      const nx=cur.x+d.x, ny=cur.y+d.y;
      if(!inBounds(nx,ny)) continue;
      if(grid[ny][nx]===WALL){
        neighbors.push({x:nx,y:ny, wx:cur.x+d.x/2, wy:cur.y+d.y/2});
      }
    }
    if(neighbors.length){
      const n=neighbors[Math.floor(Math.random()*neighbors.length)];
      grid[n.wy][n.wx]=EMPTY;
      grid[n.y][n.x]=EMPTY;
      stack.push({x:n.x,y:n.y});
    }else stack.pop();
  }

  // extra loops scale with level
  const extraOpenings = clamp(Math.floor((level-1)*2), 0, 20);
  for(let i=0;i<extraOpenings;i++){
    const x=1+Math.floor(Math.random()*(GRID_W-2));
    const y=1+Math.floor(Math.random()*(GRID_H-2));
    if(grid[y][x]===WALL){
      const openNeighbors = [
        grid[y][x-1],grid[y][x+1],grid[y-1]?.[x],grid[y+1]?.[x]
      ].filter(v=>v===EMPTY).length;
      if(openNeighbors>=2) grid[y][x]=EMPTY;
    }
  }

  // warp tunnels at mid row
  const midY=Math.floor(GRID_H/2);
  grid[midY][0]=EMPTY; grid[midY][GRID_W-1]=EMPTY;
  grid[midY][1]=EMPTY; grid[midY][GRID_W-2]=EMPTY;

  // spawn opening
  pac={x:1,y:1, dir:{x:0,y:0}};
  grid[1][1]=EMPTY; grid[1][2]=EMPTY; grid[2][1]=EMPTY; grid[2][2]=EMPTY;
}

/* ---------- Connectivity patch + dot placement ---------- */
function placeReachableDots(){
  const visited=Array.from({length:GRID_H},()=>Array(GRID_W).fill(false));
  const q=[{x:pac.x,y:pac.y}];
  visited[pac.y][pac.x]=true;
  const stepDirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  const midY=Math.floor(GRID_H/2);

  const isWalkable=(x,y)=>grid[y] && grid[y][x]!==WALL;

  while(q.length){
    const cur=q.shift();
    for(const d of stepDirs){
      let nx=cur.x+d.x, ny=cur.y+d.y;
      // wrap in mid row
      if(cur.y===midY && ny===midY){
        if(nx<0) nx=GRID_W-1;
        if(nx>=GRID_W) nx=0;
      }
      if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) continue;
      if(visited[ny][nx]) continue;
      if(!isWalkable(nx,ny)) continue;
      visited[ny][nx]=true;
      q.push({x:nx,y:ny});
    }
  }

  // clear any old dots/pellets
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      if(grid[y][x]===DOT || grid[y][x]===PELLET) grid[y][x]=EMPTY;
    }
  }

  // place dots on reachable tiles
  dotsLeft=0;
  const reachable=[];
  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      if(grid[y][x]===EMPTY && visited[y][x]){
        grid[y][x]=DOT;
        dotsLeft++;
        reachable.push({x,y});
      }
    }
  }

  // clear spawn area
  const clear=[{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:2,y:2}];
  clear.forEach(p=>{ if(grid[p.y][p.x]===DOT){ grid[p.y][p.x]=EMPTY; dotsLeft--; } });

  // place power pellets: 2‚Äì4 per level, far from spawn
  const pelletCount = clamp(2 + Math.floor((level-1)/2), 2, 4);
  reachable.sort((a,b)=>{
    const da=Math.abs(a.x-1)+Math.abs(a.y-1);
    const db=Math.abs(b.x-1)+Math.abs(b.y-1);
    return db-da;
  });

  let placed=0;
  for(const p of reachable){
    if(placed>=pelletCount) break;
    if(grid[p.y][p.x]!==DOT) continue;
    if(Math.abs(p.x-1)+Math.abs(p.y-1) < 10) continue;
    grid[p.y][p.x]=PELLET;
    placed++;
  }
}

/* ---------- Level reset (new maze + theme + ghosts) ---------- */
function resetLevel(){
  theme = themeForLevel(level);
  el("themeName").textContent = theme.name;

  generateMaze();
  placeReachableDots();

  // spawn ghosts
  ghosts=[];
  const n=ghostCountForLevel();
  for(let i=0;i<n;i++){
    const g = {
      x: GRID_W-2-i,
      y: GRID_H-2,
      dir:{x:-1,y:0},
      color: GHOST_COLORS[i % GHOST_COLORS.length],
      home:{x: GRID_W-2-i, y: GRID_H-2}
    };

    if(grid[g.y][g.x]===WALL){
      outer: for(let yy=GRID_H-2;yy>=1;yy--){
        for(let xx=GRID_W-2;xx>=1;xx--){
          if(grid[yy][xx]!==WALL){ g.x=xx; g.y=yy; g.home={x:xx,y:yy}; break outer; }
        }
      }
    }
    if(grid[g.y][g.x]===DOT || grid[g.y][g.x]===PELLET){
      grid[g.y][g.x]=EMPTY;
      dotsLeft--;
    }
    ghosts.push(g);
  }

  ghostTick=0;
  powerUntil=0;
  updateHUD();
  drawGame();
}

function updateHUD(){
  el("levelNum").textContent=String(level);
  el("movesNum").textContent=String(moves);
  el("livesNum").textContent=String(lives);
  el("dotsLeft").textContent=String(dotsLeft);
  el("ghostCount").textContent=String(ghosts.length);
  el("gameScore").textContent=String(gameScore);
  el("powerTime").textContent = powerSecondsLeft().toFixed(1);
}

/* ---------- Movement + warp ---------- */
function canMove(x,y){ return grid[y] && grid[y][x]!==WALL; }
function warpIfNeeded(nx,ny){
  const midY=Math.floor(GRID_H/2);
  if(ny===midY){
    if(nx<0) nx=GRID_W-1;
    if(nx>=GRID_W) nx=0;
  }
  return {nx,ny};
}

/* ---------- Collectibles ---------- */
function eatTile(){
  const t = grid[pac.y][pac.x];
  if(t===DOT){
    grid[pac.y][pac.x]=EMPTY;
    dotsLeft--;
    gameScore += 10;
    beep(880,0.04,0.05);
  } else if(t===PELLET){
    grid[pac.y][pac.x]=EMPTY;
    dotsLeft--;
    gameScore += 50;
    const seconds = clamp(6 + Math.floor(level/2), 6, 10);
    powerUntil = performance.now() + seconds*1000;
    beep(990,0.08,0.07,"triangle");
    beep(740,0.08,0.05,"triangle");
  }

  if(dotsLeft<=0){
    level++;
    moves += 6;
    gameScore += 200;
    beep(990,0.10,0.07);
    alert(`LEVEL UP! Level ${level} ‚Äî new theme, new maze, harder ghosts.`);
    resetLevel();
  }
}

function collideGhostIndex(){ return ghosts.findIndex(g => g.x===pac.x && g.y===pac.y); }

function loseLife(){
  lives--;
  moves = Math.max(0, moves-3);
  pac={x:1,y:1, dir:{x:0,y:0}};
  beep(220,0.12,0.07,"square");

  if(lives<=0){
    alert("Game Over ‚Äî restarting at Level 1.");
    lives=3; level=1; moves=0; gameScore=0;
    resetLevel();
  }
  updateHUD();
}

function eatGhost(g){
  gameScore += 200;
  beep(520,0.06,0.06,"sawtooth");
  beep(620,0.06,0.06,"sawtooth");
  g.x = g.home.x;
  g.y = g.home.y;
  g.dir = {x:-1,y:0};
}

/* ---------- Ghost AI ---------- */
function ghostStepOne(g){
  const options = [
    {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
  ].filter(d=>{
    let nx=g.x+d.x, ny=g.y+d.y;
    ({nx,ny}=warpIfNeeded(nx,ny));
    if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) return false;
    return canMove(nx,ny);
  });
  if(!options.length) return;

  const back={x:-g.dir.x,y:-g.dir.y};
  let filtered=options;
  if(options.length>1){
    filtered = options.filter(d=>!(d.x===back.x && d.y===back.y));
    if(!filtered.length) filtered=options;
  }

  const isPowered = powered();
  const bias = clamp(0.45 + (level-1)*0.06, 0.45, 0.85);

  let choice;
  if(Math.random() < bias){
    filtered.sort((a,b)=>{
      let ax=g.x+a.x, ay=g.y+a.y;
      let bx=g.x+b.x, by=g.y+b.y;
      ({nx:ax,ny:ay}=warpIfNeeded(ax,ay));
      ({nx:bx,ny:by}=warpIfNeeded(bx,by));
      const da=Math.abs(ax-pac.x)+Math.abs(ay-pac.y);
      const db=Math.abs(bx-pac.x)+Math.abs(by-pac.y);
      return isPowered ? (db-da) : (da-db);
    });
    choice=filtered[0];
  } else {
    choice=filtered[Math.floor(Math.random()*filtered.length)];
  }

  g.dir=choice;
  let nx=g.x+g.dir.x, ny=g.y+g.dir.y;
  ({nx,ny}=warpIfNeeded(nx,ny));
  g.x=nx; g.y=ny;
}

/* ---------- Draw ---------- */
function drawPac(px,py){
  const fill = (charMode==="ms") ? "#ffe08a" : "#ffd166";
  const d=pac.dir;
  let dirAngle=0;
  if(d.x===1) dirAngle=0;
  else if(d.x===-1) dirAngle=Math.PI;
  else if(d.y===1) dirAngle=Math.PI/2;
  else if(d.y===-1) dirAngle=-Math.PI/2;

  const mouth = (moves>0) ? 0.40 : 0.16;
  gctx.fillStyle = fill;
  gctx.beginPath();
  gctx.moveTo(px,py);
  gctx.arc(px,py, 10, dirAngle+mouth, dirAngle+(Math.PI*2-mouth));
  gctx.closePath();
  gctx.fill();

  if(charMode==="ms"){
    gctx.save();
    gctx.translate(px,py);
    const bx=-5, by=-12;
    gctx.fillStyle="#ff5c7a";
    gctx.beginPath(); gctx.ellipse(bx-3, by, 4.2, 3, 0, 0, Math.PI*2); gctx.fill();
    gctx.beginPath(); gctx.ellipse(bx+3, by, 4.2, 3, 0, 0, Math.PI*2); gctx.fill();
    gctx.fillStyle="#ffd166";
    gctx.beginPath(); gctx.arc(bx, by, 1.8, 0, Math.PI*2); gctx.fill();
    gctx.restore();
  }
}

function drawGame(){
  gctx.clearRect(0,0,game.width,game.height);

  gctx.fillStyle = theme.bg;
  gctx.fillRect(0,0,game.width,game.height);

  for(let y=0;y<GRID_H;y++){
    for(let x=0;x<GRID_W;x++){
      const t = grid[y][x];
      const px = OFFSET_X + x*TILE;
      const py = OFFSET_Y + y*TILE;

      if(t===WALL){
        gctx.fillStyle = theme.wallFill;
        gctx.fillRect(px,py,TILE,TILE);
        gctx.strokeStyle = theme.wallStroke;
        gctx.strokeRect(px+1,py+1,TILE-2,TILE-2);
      } else if(t===DOT){
        gctx.fillStyle = theme.dot;
        gctx.globalAlpha=0.90;
        gctx.beginPath();
        gctx.arc(px+TILE/2, py+TILE/2, 3.2, 0, Math.PI*2);
        gctx.fill();
        gctx.globalAlpha=1;
      } else if(t===PELLET){
        gctx.fillStyle = theme.pellet;
        gctx.globalAlpha=0.95;
        gctx.beginPath();
        gctx.arc(px+TILE/2, py+TILE/2, 6.2, 0, Math.PI*2);
        gctx.fill();
        gctx.globalAlpha=1;
      }
    }
  }

  const midY=Math.floor(GRID_H/2);
  gctx.globalAlpha=0.35;
  gctx.fillStyle=theme.pellet;
  gctx.fillRect(OFFSET_X + 0*TILE, OFFSET_Y + midY*TILE, TILE, TILE);
  gctx.fillRect(OFFSET_X + (GRID_W-1)*TILE, OFFSET_Y + midY*TILE, TILE, TILE);
  gctx.globalAlpha=1;

  const ppx = OFFSET_X + pac.x*TILE + TILE/2;
  const ppy = OFFSET_Y + pac.y*TILE + TILE/2;
  drawPac(ppx,ppy);

  const isPowered = powered();
  for(const g of ghosts){
    const gx = OFFSET_X + g.x*TILE + TILE/2;
    const gy = OFFSET_Y + g.y*TILE + TILE/2;
    const color = isPowered ? "#4da3ff" : g.color;

    gctx.fillStyle=color;
    gctx.beginPath();
    gctx.arc(gx,gy, 10, Math.PI, 0);
    gctx.lineTo(gx+10, gy+10);
    gctx.lineTo(gx+5, gy+7);
    gctx.lineTo(gx, gy+10);
    gctx.lineTo(gx-5, gy+7);
    gctx.lineTo(gx-10, gy+10);
    gctx.closePath();
    gctx.fill();

    gctx.fillStyle="rgba(0,0,0,0.35)";
    gctx.beginPath(); gctx.arc(gx-3,gy-2, 2.2,0,Math.PI*2); gctx.fill();
    gctx.beginPath(); gctx.arc(gx+3,gy-2, 2.2,0,Math.PI*2); gctx.fill();
  }
}

/* ---------- Game loop ---------- */
function gameTick(){
  ghostTick++;
  if(ghostTick % ghostSpeedFrames() === 0){
    for(const g of ghosts) ghostStepOne(g);

    const idx = collideGhostIndex();
    if(idx !== -1){
      if(powered()) eatGhost(ghosts[idx]);
      else loseLife();
    }
  }
  updateHUD();
  drawGame();
  requestAnimationFrame(gameTick);
}

/* =========================
   UI wiring + controls
   ========================= */
el("modeSelect").addEventListener("change", (e)=>{ mode=e.target.value; randomPoolCache=[]; randomIndex=0; nextQuestion(); });
el("targetSelect").addEventListener("change", (e)=>{ selectedTargetKey=e.target.value; randomPoolCache=[]; randomIndex=0; nextQuestion(); });
el("hintBtn").addEventListener("click", hint);
el("nextBtn").addEventListener("click", nextQuestion);
el("resetBtn").addEventListener("click", resetAll);

document.addEventListener("keydown",(e)=>{
  const k=e.key.toLowerCase();
  if(k==="1") chooseAnswer(0);
  if(k==="2") chooseAnswer(1);
  if(k==="3") chooseAnswer(2);
  if(k==="4") chooseAnswer(3);
  if(k==="n") nextQuestion();
  if(k==="r") resetAll();

  if(moves<=0) return;

  let dir=null;
  if(e.key==="ArrowLeft") dir={x:-1,y:0};
  if(e.key==="ArrowRight") dir={x:1,y:0};
  if(e.key==="ArrowUp") dir={x:0,y:-1};
  if(e.key==="ArrowDown") dir={x:0,y:1};
  if(!dir) return;

  let nx=pac.x+dir.x, ny=pac.y+dir.y;
  ({nx,ny}=warpIfNeeded(nx,ny));
  if(nx<0||ny<0||nx>=GRID_W||ny>=GRID_H) return;

  if(canMove(nx,ny)){
    pac.dir=dir;
    pac.x=nx; pac.y=ny;
    moves--;

    eatTile();

    const idx=collideGhostIndex();
    if(idx!==-1){
      if(powered()) eatGhost(ghosts[idx]);
      else loseLife();
    }
    updateHUD();
    drawGame();
  }
});

function resetAll(){
  for(const k of Object.keys(SKILL_TRACK)) delete SKILL_TRACK[k];
  quizAnswered=0; quizScore=0; streak=0;
  missedIds=new Set();
  updateQuizUI();

  lives=3; level=1; moves=0; gameScore=0;
  powerUntil=0;

  theme=themeForLevel(level);
  el("themeName").textContent=theme.name;

  pac={x:1,y:1, dir:{x:0,y:0}};
  resetLevel();
  renderTargetsPanel();
  nextQuestion();
  updateHUD();
  drawGame();
  beep(520,0.08,0.06);
}

/* =========================
   Init
   ========================= */
buildTargetSelect();
renderTargetsPanel();
updateQuizUI();

theme=themeForLevel(level);
el("themeName").textContent=theme.name;

resetLevel();
nextQuestion();
updateHUD();
drawGame();
gameTick();
</script>
</body>
</html>
